}
}else if (food == "high"){
if(temperature <= 15){
a <- a_high_15
b <- b_high_15
}else if(temperature >= 25){
a <- a_high_25
b <- b_high_25
}else{
a <- approx(c(15,25), c(a_high_15, a_high_25), temperature)$y
b <- approx(c(15,25), c(b_high_15, b_high_25), temperature)$y
}
}else{
stop('food must be either "low" or "high" ')
}
return(a + b * log(age))
}
# Dumont et al. (1975)
# Input: length [mm]/ Output: dry weight[mg]
dry_weight_estimation <<- function(L){
w1 = (1.89e-06*(L*1000)^2.25)/1000 #Donka Lake
w2 = (4.88e-05*(L*1000)^1.80)/1000 #River Sambre
# Selected w1 after validation with Martin-Creuzburg et al. (2018
return(w1)
}
create.inits <- function(parameters){
with( as.list(parameters),{
"Cw" = 0; "C_daphnia_unbound" = 0;
"C_daphnia_bound" = 0; "C_prot_un" = C_prot_init
return(c( "Cw" = Cw, "C_daphnia_unbound" = 0,
"C_daphnia_bound" = 0, "C_prot_un" = C_prot_init ))
})
}
ode_func <- function(time, inits, params, custom.func){
with(as.list(c(inits,params)),{
# Units explanation:
# ke: 1/day
# ku: Lwater/day
# Cw: ng PFAS/L water
# C_daphnia_unbound/C_daphnia_bound: mol PFAS/L D.magna
# C_daphnia_unbound_unmol/C_daphnia_bound_unmol: ng PFAS/g D.magna
# C_prot_un: mol prot/L
age <- init_age + time #in days
from_func <- custom.func(age, temperature, food)
#size in mm
size <- from_func$size
# dry weight in mg
DW <- from_func$DW
# Convert DW to WW
WW <- 15.5 * DW  # Conversion rate 11-20 from DW to WW (Garner et al., 2018)
# Another post discussing DW to WW can be accessed through:
#https://www.madsci.org/posts/archives/2005-09/1127049424.Zo.r.html
ku <- 10^ku
ke <- 10^ke
kon <- 10^kon
Ka <- 10^Ka
koff <- kon/Ka
C_daphnia_unbound_unmol <- C_daphnia_unbound*MW/(1000*1e-09)
C_daphnia_bound_unmol <- C_daphnia_bound*MW/(1000*1e-09)
# The concentration of the water is defined through the user input
dCw <- 0
dC_daphnia_unbound <-  ku*(Cw*1e-09/MW)/WW  - kon*C_prot_un*C_daphnia_unbound +   koff*C_daphnia_bound - ke*C_daphnia_unbound
dC_daphnia_bound <- kon*C_prot_un*C_daphnia_unbound - koff*C_daphnia_bound
dC_prot_un <-   koff*C_daphnia_bound -  kon*C_prot_un*C_daphnia_unbound
C_tot <- C_daphnia_unbound_unmol + C_daphnia_bound_unmol
return(list(c("dCw" = dCw,   "dC_daphnia_unbound" = dC_daphnia_unbound,
"dC_daphnia_bound" = dC_daphnia_bound, "dC_prot_un" = dC_prot_un),
"WW" = WW, "C_tot" = C_tot, "C_bound" = C_daphnia_bound_unmol,
"C_unbound" = C_daphnia_unbound_unmol))
})
}
WSSR <- function(observed, predicted, weights, comp.names =NULL){
# Check if the user provided the correct input format
if (!is.list(observed) || !is.list(predicted) || !is.list(weights)){
stop(" The observations, predictions and weights must be lists")
}
# Check if the user provided equal length lists
if (length(observed) != length(predicted) || length(observed) != length(weights)){
stop(" The observations, predictions and weights must have the same compartments")
}
# Define the number of observed outputs
N_outputs <- length(predicted)
# Define the number of observations per output
N_obs <- rep(NA, N_outputs)
# A vector to store the values of the weighted squared sum residuals of each compartment
outputs_res <- c()
for (i in 1:N_outputs) { # loop over the observed outputs
N_obs[i] <- length(observed[[i]])
# Check that all observed, predicted and weights vectors have the same length
if(N_obs[i] != length(predicted[[i]]) || N_obs[i] != length(weights[[i]])){
stop(paste0("Compartment ",i," had different length in the observations and predictions"))
}
# The number of observations for output i
N <- N_obs[i]
# Initiate a variable to estimate the sum of squared residuals for output j
sq_weighted_res_j <- 0
for (j in 1:N) { #loop over the experimental points i compartment i
sq_weighted_res_j <- sq_weighted_res_j + ((observed[[i]][j] - predicted[[i]][j]) / weights[[i]][j])^2
}
outputs_res[i] <- sq_weighted_res_j
}
WSSR_results <- sum(outputs_res)
# Name the list of compartment discrepancy indices
if ( !is.null(comp.names)){
names(WSSR_results) <- comp.names
}else if (!is.null(names(observed))){
names(WSSR_results) <- names(observed)
} else if (!is.null(names(predicted)) && is.null(comp.names) ){
names(WSSR_results) <- names(predicted)
} else if (!is.null(names(weights)) && is.null(comp.names) ){
names(WSSR_results) <- names(weights)
}
return(WSSR_results)
}
data_ls <- openxlsx::read.xlsx ('C:/Users/vassi/Documents/GitHub/PFAS_biokinetics_models/D.Magna/Wang_2023/Wang_data_reduced2.xlsx', sheet = "PFDA")
data_plot <- openxlsx::read.xlsx ('C:/Users/vassi/Documents/GitHub/PFAS_biokinetics_models/D.Magna/Wang_2023/Wang_data.xlsx', sheet = "PFDA")
opts <- list( "algorithm" = "NLOPT_LN_SBPLX", #"NLOPT_LN_BOBYQA" #"NLOPT_LN_COBYLA"
"xtol_rel" = 1e-08,
"ftol_rel" = 1e-08,
"ftol_abs" = 0.0,
"xtol_abs" = 0.0 ,
"maxeval" = 20,
"print_level" = 1)
# Convert water concentration in ng/L
Cwater = c(18.50, 19.60, 21.90)*1000
names(Cwater) <- c("16oC", "20oC", "24oC")
age = 7+7 # age of D.magna at the beginning of exposure in days
temperatures <- c(16, 20, 24) #experiment temperature in oC
MW <- 514 # molecular weight of PFDA
# Define initial values of fitted parameters to provide to the optimization routine
# For each PFAS and temperature combination we have two parameters
x0 <- c(7, 6, 6, 8, 1e-04)
set.seed(12312)
x<-x0
# Indexes of body burden and exposure time in data frame
BB_index <- c(2,4,6)
ExpTime_index <- c(1,3,5)
# Age of D.magna at beginning of exposure
init_age <- age
# Create a counter to mark the position of fitted parameters of x
# that corresponds to a specific combination of PFAS and temperature
counter <- 1
score <- rep(NA, length(temperatures))
# Iterate over PFAS names
# Load PFAS data
df <- PFAS_data
PFAS_data = data_ls
PFAS_name = "PFDA"
Cwater
age
temperatures
MW
metric
# Indexes of body burden and exposure time in data frame
BB_index <- c(2,4,6)
ExpTime_index <- c(1,3,5)
# Age of D.magna at beginning of exposure
init_age <- age
# Create a counter to mark the position of fitted parameters of x
# that corresponds to a specific combination of PFAS and temperature
counter <- 1
score <- rep(NA, length(temperatures))
# Iterate over PFAS names
# Load PFAS data
df <- PFAS_data
# Iterate over number of distinct temperature used in the experiment
ku <- x[1]
kon <- x[2]
Ka <- x[3]
ke <- x[4]
C_prot_init <- x[5]
for (temp_iter in 1:length(temperatures)){
# Initial water concentration of PFAS at selected temperature
C_water <-  Cwater[temp_iter]
# Temperature of experiment
Temp <- temperatures[temp_iter]
# Time of measurement of selected PFAS at selected temperature
exp_time <- round(df[!is.na(df[,ExpTime_index[temp_iter]]),ExpTime_index[temp_iter]],1)
# Body burden of selected PFAS at selected temperature
BodyBurden <- df[!is.na(df[,BB_index[temp_iter]]),BB_index[temp_iter]]
# Time used by numerical solver that integrates the system of ODE
sol_times <- seq(0,15, 0.1 )
# Fitted parameters
inits <- c( "Cw" = C_water,  "C_daphnia_unbound" = 0,
"C_daphnia_bound" = 0, "C_prot_un" = C_prot_init)
params <- c("init_age"=age, "Temp" = Temp, "ku"= ku,
"kon" = kon, "Ka" = Ka, "ke"= ke, "MW" = MW)
solution <- data.frame(deSolve::ode(times = sol_times,  func = ode_func,
y = inits,
parms = params,
method="lsodes",
rtol = 1e-5, atol = 1e-5))
if(sum(round(solution$time,2) %in% exp_time) == length(exp_time)){
results <- solution[which(round(solution$time,2) %in% exp_time), 'C_tot']
}else{
stop(print("Length of predictions is not equal to the length of data"))
}
score[temp_iter] <- WSSR(list(BodyBurden), list(results))
}
# Time used by numerical solver that integrates the system of ODE
sol_times <- seq(0,15, 0.1 )
inits <- c( "Cw" = C_water,  "C_daphnia_unbound" = 0,
"C_daphnia_bound" = 0, "C_prot_un" = C_prot_init)
params <- c("init_age"=age, "Temp" = Temp, "ku"= ku,
"kon" = kon, "Ka" = Ka, "ke"= ke, "MW" = MW)
obj_func <- function(x, PFAS_data, PFAS_name, Cwater, age, temperatures, MW, metric){
# Indexes of body burden and exposure time in data frame
BB_index <- c(2,4,6)
ExpTime_index <- c(1,3,5)
# Age of D.magna at beginning of exposure
init_age <- age
# Create a counter to mark the position of fitted parameters of x
# that corresponds to a specific combination of PFAS and temperature
counter <- 1
score <- rep(NA, length(temperatures))
# Iterate over PFAS names
# Load PFAS data
df <- PFAS_data
# Iterate over number of distinct temperature used in the experiment
ku <- x[1]
kon <- x[2]
Ka <- x[3]
ke <- x[4]
C_prot_init <- x[5]
for (temp_iter in 1:length(temperatures)){
# Initial water concentration of PFAS at selected temperature
C_water <-  Cwater[temp_iter]
# Temperature of experiment
Temp <- temperatures[temp_iter]
# Time of measurement of selected PFAS at selected temperature
exp_time <- round(df[!is.na(df[,ExpTime_index[temp_iter]]),ExpTime_index[temp_iter]],1)
# Body burden of selected PFAS at selected temperature
BodyBurden <- df[!is.na(df[,BB_index[temp_iter]]),BB_index[temp_iter]]
# Time used by numerical solver that integrates the system of ODE
sol_times <- seq(0,15, 0.1 )
# Fitted parameters
inits <- c( "Cw" = C_water,  "C_daphnia_unbound" = 0,
"C_daphnia_bound" = 0, "C_prot_un" = C_prot_init)
params <- c("init_age"=age, "Temp" = Temp, "ku"= ku,
"kon" = kon, "Ka" = Ka, "ke"= ke, "MW" = MW)
solution <- data.frame(deSolve::ode(times = sol_times,  func = ode_func,
y = inits,
parms = params,
method="lsodes",
rtol = 1e-5, atol = 1e-5))
if(sum(round(solution$time,2) %in% exp_time) == length(exp_time)){
results <- solution[which(round(solution$time,2) %in% exp_time), 'C_tot']
}else{
stop(print("Length of predictions is not equal to the length of data"))
}
score[temp_iter] <- WSSR(list(BodyBurden), list(results))
}
# Take the average score of all PFAS and temperatures
final_score <- mean(score)
return(final_score)
}
temp_iter<-1
# Initial water concentration of PFAS at selected temperature
C_water <-  Cwater[temp_iter]
# Temperature of experiment
Temp <- temperatures[temp_iter]
# Time of measurement of selected PFAS at selected temperature
exp_time <- round(df[!is.na(df[,ExpTime_index[temp_iter]]),ExpTime_index[temp_iter]],1)
# Body burden of selected PFAS at selected temperature
BodyBurden <- df[!is.na(df[,BB_index[temp_iter]]),BB_index[temp_iter]]
# Time used by numerical solver that integrates the system of ODE
sol_times <- seq(0,15, 0.1 )
inits <- c( "Cw" = C_water,  "C_daphnia_unbound" = 0,
"C_daphnia_bound" = 0, "C_prot_un" = C_prot_init)
params <- c("init_age"=age, "Temp" = Temp, "ku"= ku,
"kon" = kon, "Ka" = Ka, "ke"= ke, "MW" = MW)
solution <- data.frame(deSolve::ode(times = sol_times,  func = ode_func,
y = inits,
parms = params,
method="lsodes",
rtol = 1e-5, atol = 1e-5))
ode_func <- function(time, inits, params){
with(as.list(c(inits, params)),{
# Units explanation:
# ke: 1/day
# ku: Lwater/day
# Cw: ng PFAS/L water
# C_daphnia_unbound/C_daphnia_bound: mol PFAS/L D.magna
# C_daphnia_unbound_unmol/C_daphnia_bound_unmol: ng PFAS/g D.magna
# C_prot_un: mol prot/L
age <- init_age + time
#size in mm
size <- Size_estimation(age, temperature = 23, food="high")
# dry weight mg
DW <- dry_weight_estimation(size)
# Convert DW to WW
WW <- 15.5 * DW  # Conversion rate 11-20 from DW to WW (Garner et al., 2018)
# Another post discussing DW to WW can be accessed through:
#https://www.madsci.org/posts/archives/2005-09/1127049424.Zo.r.html
# Water concentration in ng/L
dCw <- 0
# D.magna concentration in lumenconcentration in ng/g
ku <- 10^ku
ke <- 10^ke
kon <- 10^kon
Ka <- 10^Ka
koff <- kon/Ka
# Reported values for Kon and koff range between 1e2-1e04 and 1e-3-1e-1 in L/mol/s
# and s-^-1 respectively. Our concentrations are in ng/g. Assuming density = 1000g/L
# then the concentration in ng/g is multyplied by 1000 to make it ng/L and then by
# multiply by 1e-9 to make it grams and divide by MW. We do this directly to kon
# and koff to make the concentration mol/L so that we can match the literature
# values of kon and koff with ours
C_daphnia_unbound_unmol <- C_daphnia_unbound*MW/(1000*1e-09)
C_daphnia_bound_unmol <- C_daphnia_bound*MW/(1000*1e-09)
dC_daphnia_unbound <-  ku*(Cw*1e-09/MW)/WW  - kon*C_prot_un*C_daphnia_unbound +   koff*C_daphnia_bound - ke*C_daphnia_unbound
dC_daphnia_bound <- kon*C_prot_un*C_daphnia_unbound - koff*C_daphnia_bound
dC_prot_un <-   koff*C_daphnia_bound -  kon*C_prot_un*C_daphnia_unbound
C_tot <- C_daphnia_unbound_unmol + C_daphnia_bound_unmol
return(list(c("dCw" = dCw,   "dC_daphnia_unbound" = dC_daphnia_unbound,
"dC_daphnia_bound" = dC_daphnia_bound, "dC_prot_un" = dC_prot_un),
"WW" = WW, "C_tot" = C_tot))
})
}
deSolve::ode(times = sol_times,  func = ode_func,
y = inits,
parms = params,
method="lsodes",
rtol = 1e-5, atol = 1e-5)
solution <- data.frame(deSolve::ode(times = sol_times,  func = ode_func,
y = inits,
parms = params,
method="lsodes",
rtol = 1e-5, atol = 1e-5))
C_water
inits <- c( "Cw" = C_water,  "C_daphnia_unbound" = 0,
"C_daphnia_bound" = 0, "C_prot_un" = C_prot_init)
inits
C_water[[]]
C_water[]
C_water
C_water[[1]]
C_water[[1]]
C_water[[]]
C_water[]
C_water[1]
inits <- c( "Cw" = C_water[[1]],  "C_daphnia_unbound" = 0,
"C_daphnia_bound" = 0, "C_prot_un" = C_prot_init)
inits
params <- c("init_age"=age, "Temp" = Temp, "ku"= ku,
"kon" = kon, "Ka" = Ka, "ke"= ke, "MW" = MW)
solution <- data.frame(deSolve::ode(times = sol_times,  func = ode_func,
y = inits,
parms = params,
method="lsodes",
rtol = 1e-5, atol = 1e-5))
head(solution)
tail(solution)
if(sum(round(solution$time,2) %in% exp_time) == length(exp_time)){
results <- solution[which(round(solution$time,2) %in% exp_time), 'C_tot']
}else{
stop(print("Length of predictions is not equal to the length of data"))
}
score[temp_iter] <- WSSR(list(BodyBurden), list(results))
list(BodyBurden)
list(results)
weights_values <- runif(6)
score[temp_iter] <- WSSR(list(BodyBurden), list(results), weights_values)
score[temp_iter] <- WSSR(list(BodyBurden), list(results), list(weights_values))
score
for (temp_iter in 1:length(temperatures)){
# Initial water concentration of PFAS at selected temperature
C_water <-  Cwater[temp_iter]
# Temperature of experiment
Temp <- temperatures[temp_iter]
# Time of measurement of selected PFAS at selected temperature
exp_time <- round(df[!is.na(df[,ExpTime_index[temp_iter]]),ExpTime_index[temp_iter]],1)
# Body burden of selected PFAS at selected temperature
BodyBurden <- df[!is.na(df[,BB_index[temp_iter]]),BB_index[temp_iter]]
# Time used by numerical solver that integrates the system of ODE
sol_times <- seq(0,15, 0.1 )
# Fitted parameters
inits <- c( "Cw" = C_water[[1]],  "C_daphnia_unbound" = 0,
"C_daphnia_bound" = 0, "C_prot_un" = C_prot_init)
params <- c("init_age"=age, "Temp" = Temp, "ku"= ku,
"kon" = kon, "Ka" = Ka, "ke"= ke, "MW" = MW)
solution <- data.frame(deSolve::ode(times = sol_times,  func = ode_func,
y = inits,
parms = params,
method="lsodes",
rtol = 1e-5, atol = 1e-5))
if(sum(round(solution$time,2) %in% exp_time) == length(exp_time)){
results <- solution[which(round(solution$time,2) %in% exp_time), 'C_tot']
}else{
stop(print("Length of predictions is not equal to the length of data"))
}
weights_values <- runif(6)
score[temp_iter] <- WSSR(list(BodyBurden), list(results), list(weights_values))
}
score
# Take the average score of all PFAS and temperatures
final_score <- mean(score)
obj_func <- function(x, PFAS_data, PFAS_name, Cwater, age, temperatures, MW, metric){
# Indexes of body burden and exposure time in data frame
BB_index <- c(2,4,6)
ExpTime_index <- c(1,3,5)
# Age of D.magna at beginning of exposure
init_age <- age
# Create a counter to mark the position of fitted parameters of x
# that corresponds to a specific combination of PFAS and temperature
counter <- 1
score <- rep(NA, length(temperatures))
# Iterate over PFAS names
# Load PFAS data
df <- PFAS_data
# Iterate over number of distinct temperature used in the experiment
ku <- x[1]
kon <- x[2]
Ka <- x[3]
ke <- x[4]
C_prot_init <- x[5]
for (temp_iter in 1:length(temperatures)){
# Initial water concentration of PFAS at selected temperature
C_water <-  Cwater[temp_iter]
# Temperature of experiment
Temp <- temperatures[temp_iter]
# Time of measurement of selected PFAS at selected temperature
exp_time <- round(df[!is.na(df[,ExpTime_index[temp_iter]]),ExpTime_index[temp_iter]],1)
# Body burden of selected PFAS at selected temperature
BodyBurden <- df[!is.na(df[,BB_index[temp_iter]]),BB_index[temp_iter]]
# Time used by numerical solver that integrates the system of ODE
sol_times <- seq(0,15, 0.1 )
# Fitted parameters
inits <- c( "Cw" = C_water[[1]],  "C_daphnia_unbound" = 0,
"C_daphnia_bound" = 0, "C_prot_un" = C_prot_init)
params <- c("init_age"=age, "Temp" = Temp, "ku"= ku,
"kon" = kon, "Ka" = Ka, "ke"= ke, "MW" = MW)
solution <- data.frame(deSolve::ode(times = sol_times,  func = ode_func,
y = inits,
parms = params,
method="lsodes",
rtol = 1e-5, atol = 1e-5))
if(sum(round(solution$time,2) %in% exp_time) == length(exp_time)){
results <- solution[which(round(solution$time,2) %in% exp_time), 'C_tot']
}else{
stop(print("Length of predictions is not equal to the length of data"))
}
weights_values <- runif(6)
score[temp_iter] <- WSSR(list(BodyBurden), list(results), list(weights_values))
}
# Take the average score of all PFAS and temperatures
final_score <- mean(score)
return(final_score)
}
obj_func <- function(x, PFAS_data, PFAS_name, Cwater, age, temperatures, MW){
# Indexes of body burden and exposure time in data frame
BB_index <- c(2,4,6)
ExpTime_index <- c(1,3,5)
# Age of D.magna at beginning of exposure
init_age <- age
# Create a counter to mark the position of fitted parameters of x
# that corresponds to a specific combination of PFAS and temperature
counter <- 1
score <- rep(NA, length(temperatures))
# Iterate over PFAS names
# Load PFAS data
df <- PFAS_data
# Iterate over number of distinct temperature used in the experiment
ku <- x[1]
kon <- x[2]
Ka <- x[3]
ke <- x[4]
C_prot_init <- x[5]
for (temp_iter in 1:length(temperatures)){
# Initial water concentration of PFAS at selected temperature
C_water <-  Cwater[temp_iter]
# Temperature of experiment
Temp <- temperatures[temp_iter]
# Time of measurement of selected PFAS at selected temperature
exp_time <- round(df[!is.na(df[,ExpTime_index[temp_iter]]),ExpTime_index[temp_iter]],1)
# Body burden of selected PFAS at selected temperature
BodyBurden <- df[!is.na(df[,BB_index[temp_iter]]),BB_index[temp_iter]]
# Time used by numerical solver that integrates the system of ODE
sol_times <- seq(0,15, 0.1 )
# Fitted parameters
inits <- c( "Cw" = C_water[[1]],  "C_daphnia_unbound" = 0,
"C_daphnia_bound" = 0, "C_prot_un" = C_prot_init)
params <- c("init_age"=age, "Temp" = Temp, "ku"= ku,
"kon" = kon, "Ka" = Ka, "ke"= ke, "MW" = MW)
solution <- data.frame(deSolve::ode(times = sol_times,  func = ode_func,
y = inits,
parms = params,
method="lsodes",
rtol = 1e-5, atol = 1e-5))
if(sum(round(solution$time,2) %in% exp_time) == length(exp_time)){
results <- solution[which(round(solution$time,2) %in% exp_time), 'C_tot']
}else{
stop(print("Length of predictions is not equal to the length of data"))
}
weights_values <- runif(6)
score[temp_iter] <- WSSR(list(BodyBurden), list(results), list(weights_values))
}
# Take the average score of all PFAS and temperatures
final_score <- mean(score)
return(final_score)
}
optimization<- nloptr::nloptr(x0 = x0,
eval_f = obj_func,
lb	=  c(5,-1,1,5, 1e-07),
ub =   c(12,10, 9, 12,  1e-03),
opts = opts,
PFAS_data = data_ls,
PFAS_name = "PFDA",
Cwater = Cwater,
age = age ,
temperatures = temperatures,
MW = MW)
